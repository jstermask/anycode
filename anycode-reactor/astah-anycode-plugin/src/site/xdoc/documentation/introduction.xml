<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">
	<head>
		<title>Reference documentation - Introduction</title>
	</head>
	<body>
		<h1>1. Introduction</h1>
		<section name="1.1. Code generation process">
			<a name="11"></a>
			<p>When working with Astah, any class you design in a diagram is registered in project's model. You can see them in the
				"Structure" panel. Anycode generation process takes each of them into account, except the already existing ones that belongs
				to java.* package.
			</p>
			<p> By default, if you haven't created at least one template, nothing will be generated at all, as a template represents the
				minimum piece of transformation of your model. If you create one, the later will automatically be passed each of your
				classes. In other words, the process is a kind of cartesian product between UML Classes and custom templates as it iterates
				on each UML Class, and for each one, it iterates on each template found in the directory you configure.
			</p>
			<p class="pcenter">
				<img class="screenshot" src="images/code-generation-process.png" />
			</p>
			<p>
				Fortunately, it's possible to narrow a template to only specific classes. For further details about this, please see
				<i>Conditional Rendering section</i>
				of this guide.
			</p>
		</section>
		<section name="1.2. Astah API">
			<a name="12"></a>
			<p>Astah provides </p>
		</section>
		<section name="Template programming language">
				<p>
					A template is a Groovy template, and therefore must be coded in <b>Groovy</b> language. It would not make sense to describe this language here as everything is already well documented in the official
					<a href="http://groovy.codehaus.org/Groovy+Templates" target="_blank">Groovy Templates documentation</a>
					. You'll learn there how code loops, conditions, closures, how to manipulate strings, arrays...
				</p>
		</section>
		
		<section name="Input Parameters">
			<p> To render itself, a template always receives a context as a parameter. It's a set of 3 variables that you can call from
				the template:
			</p>
			<table>
				<tr>
					<th>Parameter name</th>
					<th>Description</th>
					<th>Type</th>
				</tr>
				<tr>
					<td>c</td>
					<td>Wrapper for each astah class. c variable is an instance of Anycode API IClass object.
					</td>
					<td>in.labulle.anycode.uml.IClass</td>
				</tr>
				<tr>
					<td>targetDir</td>
					<td>Target directory that you chose from anycode configuration panel. This will be useful to build the name of the
						generated file (its path).
					</td>
					<td>java.lang.String</td>
				</tr>
				<tr>
					<td>templateDir</td>
					<td>Template directory that you chose from anycode configuration panel.
					</td>
					<td>java.lang.String</td>
				</tr>
			</table>
			<p>
				IClass is an interface provided by Anycode API whose javadoc is available online here. It wraps class designed in Astah. From
				the template, you can therefore access a UML Class information, its name, package, attributes, operations, relations,
				stereotypes... To sum up, you can have access to (almost?) anything you designed in your diagram. And the good news is that
				Anycode API is quite easy to use. For practical details, please see
				<i>Template snippets section</i>
				of this guide.
			</p>
		</section>
		<section name="Templating conventions">
			<subsection name="Template structure">
				<p>When you develop, you always end up typing some text in a file which is generally created by your favorite IDE. Depending
					on the language you use, file's content and name must follow specific coding conventions to be interpreted/compiled. That is
					the reason why a custom template allows you to customize both the content of your class (the code), and the name of the file
					where the code is stored.
				</p>
				<p>
					Therefore, a template is
					<b>always</b>
					made of two files, that must comply with the following naming convention:
				</p>
				<table>
					<tr>
						<th>Prefix</th>
						<th>Suffix</th>
						<th>Extension</th>
						<th>Description</th>
						<th>Example</th>
					</tr>
					<tr>
						<td>Any valid filename</td>
						<td>-name</td>
						<td>.mda or .mdc</td>
						<td>Template that is responsible for generating source code file's path</td>
						<td>mydto-name.mda</td>
					</tr>
					<tr>
						<td>Any valid filename</td>
						<td>-content</td>
						<td>.mda or .mdc</td>
						<td>Template that is responsible for generating source code content</td>
						<td>mydto-content.mda</td>
					</tr>
				</table>
				<p>2 files <i>[foo]</i>-name.mda and <i>[foo]</i>-content.mda compose one template identified as <i>[foo]</i> template.</p>
			</subsection>
			
			<subsection name="Conditional rendering">
				<p>As we said before, code generation process generates each class with each template by default. So you may wonder how you
					can do to write a template that will generate DAO classes, and service classes that only matches a subset of all the classes
					you modelled.
				</p>
				<p>In
					fact, all you have to do is to code a <code>&lt;#if&gt;[...]&lt;/#if&gt;</code> condition in
					<code>-content</code>
					template that surrounds all the template. As a consequence, if this condition is not matched, template output content will be
					empty. Code generation process will then ignore source code generation and won't write any output file.
				</p>
				<p>A very common condition is to check a classes' stereotype. For instance, you could define an &lt;&lt;Entity&gt;&gt;
					stereotype in Astah, write a persistence class template surrounded by a condition to ensure that class must have this
					stereotype in order to be generated. 
				</p>
			</subsection>
			<subsection name="Override mechanism">
				<p>Sometimes you want a class to be overwritten each time you launch code generation. However, this might no always be the best choice, especially if
					you are willing to generated source code that you want to modify yourself afterwards (skeletons or implementation classes).
				</p>
				<p>Template file extension will give you the opportunity to choose whether you must always override the generated source code,
					or not :</p>
				<ul>
					<li><b>.mda</b> : your template will overwrite any existing target source code and replace its content.</li>
					<li><b>.mdc</b> : your template will create the target source file if it doesn't exist but will let the target file unchanged if it
						already exists.</li>
				</ul>
			</subsection>
		</section>
		<section name="Template snippets">
<p>This section will give you practical examples to start generating your own source code. It will be regularly updated to give you more and more help.</p>
			<subsection name="Class">
<source>
&lt;#-- Display class name --&gt;
${model.c.name}

&lt;#-- Class fully qualified name (separated by '.') --&gt;
${model.c.getFullName(".")}

&lt;#-- Class package (separated by '.') --&gt;
${model.c.getFullNamespace(".")}

&lt;#-- A php class source path (common use 
case for -name template) in target directory --&gt;
${targetDir}/${model.c.getFullName("/").php}
</source>
			</subsection>
			<subsection name="Attributes">
<source>
&lt;#-- Iterating over attributes --&gt;
&lt;#list model.c.attributes as anAttribute&gt;
	&lt;#-- anAttribute if an IAttribute astah object. --&gt;
&lt;/#list&gt;
</source>			
			</subsection>
			<subsection name="Operations">
<source>
&lt;#-- Iterating over operations --&gt;
&lt;#list model.c.operations as anOperation&gt;
	&lt;#-- anOperation if an IOperation astah object. --&gt;
&lt;/#list&gt;
</source>				
			</subsection>
			<subsection name="Relations">
<p>Simple attributes and relations are both listed in the attributes of the owning class. However you can easily distinguish them by checking 'association' method and also 'multiplicity'.</p>
<source>
&lt;#-- We suppose here that you are iterating over 
attributes, and 'att' is an attribute variable --&gt;
&lt;#if !att.multiplicity?has_content&gt;
	&lt;#-- This means this attribute is a not a 
	relation but a simple attribute --&gt;
&lt;/#if&gt;

&lt;#if att.multiplicity?has_content &amp;&amp; 
		att.multiplicity[0].upper == 1 &gt;
	&lt;#-- This means attribute is a one to one or 
		many to one relation --&gt;
&lt;/#if&gt;

&lt;#if att.multiplicity?has_content &amp;&amp; 
			att.multiplicity[0].upper == -1 &gt;
	&lt;#-- This means attribute is a part of one to 
		many or many to many --&gt;
&lt;/#if&gt;

&lt;#local many = true /&gt;
&lt;#list att.association.memberEnds as att1&gt;
	&lt;#if !(att1.multiplicity?has_content &amp;&amp; 
			att.multiplicity[0].upper == -1)&gt;
		&lt;#local many = false /&gt;
	&lt;/#if>
&lt;/#list&gt;
&lt;#-- if local variable 'many' is true then relation
	 is a many to many --&gt;
</source>		
			</subsection>
			<subsection name="Dependencies">
<source>
&lt;#list model.c.clientDependencies as dep&gt;
	&lt;#-- 'dep' is a IClass object c depends on. --&gt;	
&lt;/#list&gt;
</source>
			</subsection>
			<subsection name="Inheritance">
<source>
&lt;#-- Displays coma separated list of supertypes  --&gt;
&lt;#list model.c.generalizations as parent&gt;
	${parent.superType.name}&lt;#if parent_has_next&gt;, &lt;/#if&gt;	
&lt;/#list&gt;
</source>
			</subsection>
			<subsection name="Stereotypes">
<source>
&lt;#if model.c.stereotypes?seq_contains("Entity") &gt;
	&lt;#-- means that class has stereotype 'Entity' --&gt;
&lt;/#if&gt;
</source>
			</subsection>
		</section>

		<section name="Using macros and directives">
			<subsection name="Macros">
				<p>
					As you can imagine, your templates' size will grow a lot if you have to code the above snippets everytime you need them. Freemarker fortunately provides
					a <a href="http://freemarker.org/docs/ref_directive_macro.html" target="_blank">Macro</a> mechanism that will enable you to create you own re-usable fragments of templates.
				</p>
				<p>
				Let's take a very simple example : suppose you need to generate a PHP attribute of a class as well as its getters and setters. You can then write all the code in the macro as 
				you can see in the <i>-content.mda</i> template below :
				</p>
				<code><b>yetanothertemplate-name.mda</b></code>
				<source>
${targetDir}/${model.c.name}.php
				</source> 
				<code><b>yetanothertemplate-content.mda</b></code>
				<source>
&lt;#macro attribute att&gt;
var ${att.name};
function get${att.name?cap_first}() {
	return ${att.name};
}
	
function set${att.name?cap_first}($a${att.name?cap_first}) {
	$this->${att.name} = $a${att.name?cap_first};
}
&lt;/#macro&gt;
&lt;?php
class ${model.c.name} {
	&lt;#list model.c.attributes as att&gt;
	&lt;@attribute att/&gt;
	&lt;/#list&gt;
}
?&gt;	
				</source>
				<p>And the result below with a simple Person class with 3 attributes :</p>
				
				<code><b>Person.php</b></code>
				<source>
&lt;?php
class Person {
var firstname;
function getFirstname() {
	return $this->{att.name};
}
	
function setFirstname($aFirstname) {
	$this->firstname = $aFirstname;
}
var lastname;
function getLastname() {
	return $this->{att.name};
}
	
function setLastname($aLastname) {
	$this->lastname = $aLastname;
}
var birthdate;
function getBirthdate() {
	return $this->{att.name};
}
	
function setBirthdate($aBirthdate) {
	$this->birthdate = $aBirthdate;
}
}
?&gt;
				</source>
				<p>
				Well the source code is now more readable but the macro is still in our template file, and therefore it cannot be reused... Don't worry, let's put it  in a separate file and use the latter
				with a directive !
				</p>
			</subsection>
			<subsection name="Directives">
				<p>
					Another reason why we chose Freemarker for templates is directives. Let's create a directive file, located <b>in the same directory</b> where we put all our previous templates:
				</p>
				<code><b>mymacros.mda</b></code>
				<source>
&lt;#macro attribute att&gt;
var ${att.name};
function get${att.name?cap_first}() {
	return $this->${att.name};
}
	
function set${att.name?cap_first}($a${att.name?cap_first}) {
	$this->${att.name} = $a${att.name?cap_first};
}
&lt;/#macro&gt;			
				</source>
				<p>Now, let's use this macro in our template :</p>
				<code><b>yetanothertemplate-content.mda</b></code>
				<source>
&lt;#import "mymacros.mda" as my/&gt;
&lt;?php
class ${model.c.name} {
	&lt;#list model.c.attributes as att&gt;
	&lt;@my.attribute att/&gt;
	&lt;/#list&gt;
}
?&gt;	
				</source>
				<p>Thanks to this process you can define your own directives and make source code generation very easy.</p>
			</subsection>
		</section>
		<section name="Built-in directives">
			<p>
			If you don't have time to write you own directives, you'll be happy to know that future releases of anycode will soon provide (in some weeks/months) built-in directives for most common languages and technologies.
			These directives will be automatically imported into all your templates thanks to auto-import mechanism of Freemarker. Be patient !
			</p>
		</section>
	</body>
</document>